diff --git a/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/JdbcExecutorFactory.java b/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/JdbcExecutorFactory.java
index c5866fcc35..deabae69f0 100644
--- a/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/JdbcExecutorFactory.java
+++ b/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/JdbcExecutorFactory.java
@@ -43,6 +43,8 @@ public class JdbcExecutorFactory {
                 return "org/apache/doris/jdbc/TrinoJdbcExecutor";
             case GBASE:
                 return "org/apache/doris/jdbc/GbaseJdbcExecutor";
+            case KINGBASE:
+                return "org/apache/doris/jdbc/KingBaseJdbcExecutor";
             default:
                 throw new IllegalArgumentException("Unsupported jdbc type: " + type);
         }
diff --git a/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/KingBaseJdbcExecutor.java b/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/KingBaseJdbcExecutor.java
index 8bb862a370..25a8335c0b 100644
--- a/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/KingBaseJdbcExecutor.java
+++ b/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/KingBaseJdbcExecutor.java
@@ -15,5 +15,114 @@
 // specific language governing permissions and limitations
 // under the License.
 
-package org.apache.doris.jdbc;public class KingBaseJdbcExecutor {
+package org.apache.doris.jdbc;
+
+
+import org.apache.doris.common.jni.vec.ColumnType;
+import org.apache.doris.common.jni.vec.ColumnType.Type;
+import org.apache.doris.common.jni.vec.ColumnValueConverter;
+import org.apache.doris.common.jni.vec.VectorTable;
+
+import com.zaxxer.hikari.HikariDataSource;
+
+import java.math.BigDecimal;
+import java.sql.Date;
+import java.sql.SQLException;
+import java.sql.Timestamp;
+import java.sql.Types;
+
+public class KingBaseJdbcExecutor extends BaseJdbcExecutor {
+    public KingBaseJdbcExecutor(byte[] thriftParams) throws Exception {
+        super(thriftParams);
+    }
+
+    @Override
+    protected void setValidationQuery(HikariDataSource ds) {
+        ds.setConnectionTestQuery("SELECT 1 FROM dual");
+    }
+
+    @Override
+    protected void initializeBlock(int columnCount, String[] replaceStringList, int batchSizeNum,
+            VectorTable outputTable) {
+        for (int i = 0; i < columnCount; ++i) {
+            if (outputTable.getColumnType(i).getType() == Type.STRING) {
+                block.add(new Object[batchSizeNum]);
+            } else {
+                block.add(outputTable.getColumn(i).newObjectContainerArray(batchSizeNum));
+            }
+        }
+    }
+
+    @Override
+    protected Object getColumnValue(int columnIndex, ColumnType type, String[] replaceStringList) throws SQLException {
+        switch (type.getType()) {
+            case BOOLEAN:
+                boolean booleanVal = resultSet.getBoolean(columnIndex + 1);
+                return resultSet.wasNull() ? null : booleanVal;
+            case TINYINT:
+                byte tinyIntVal = resultSet.getByte(columnIndex + 1);
+                return resultSet.wasNull() ? null : tinyIntVal;
+            case SMALLINT:
+                short smallIntVal = resultSet.getShort(columnIndex + 1);
+                return resultSet.wasNull() ? null : smallIntVal;
+            case INT:
+                int intVal = resultSet.getInt(columnIndex + 1);
+                return resultSet.wasNull() ? null : intVal;
+            case BIGINT:
+                long bigIntVal = resultSet.getLong(columnIndex + 1);
+                return resultSet.wasNull() ? null : bigIntVal;
+            case FLOAT:
+                float floatVal = resultSet.getFloat(columnIndex + 1);
+                return resultSet.wasNull() ? null : floatVal;
+            case DOUBLE:
+                double doubleVal = resultSet.getDouble(columnIndex + 1);
+                return resultSet.wasNull() ? null : doubleVal;
+            case DECIMALV2:
+            case DECIMAL32:
+            case DECIMAL64:
+            case DECIMAL128:
+                BigDecimal decimalVal = resultSet.getBigDecimal(columnIndex + 1);
+                return resultSet.wasNull() ? null : decimalVal;
+            case DATE:
+            case DATEV2:
+                Date dateVal = resultSet.getDate(columnIndex + 1);
+                return resultSet.wasNull() ? null : dateVal.toLocalDate();
+            case DATETIME:
+            case DATETIMEV2:
+                Timestamp timestampVal = resultSet.getTimestamp(columnIndex + 1);
+                return resultSet.wasNull() ? null : timestampVal.toLocalDateTime();
+            case CHAR:
+            case VARCHAR:
+            case STRING:
+                int jdbcType = resultSetMetaData.getColumnType(columnIndex + 1);
+                if (jdbcType == Types.TIME) {
+                    String timeString = resultSet.getString(columnIndex + 1);
+                    return resultSet.wasNull() ? null : timeString;
+                } else {
+                    Object stringVal = resultSet.getObject(columnIndex + 1);
+                    return resultSet.wasNull() ? null : stringVal;
+                }
+            default:
+                throw new IllegalArgumentException("Unsupported column type: " + type.getType());
+        }
+    }
+
+    @Override
+    protected ColumnValueConverter getOutputConverter(ColumnType columnType, String replaceString) {
+        switch (columnType.getType()) {
+            case CHAR:
+                return createConverter(
+                        input -> trimSpaces(input.toString()), String.class);
+            case STRING:
+                return createConverter(input -> {
+                    if (input instanceof java.sql.Time) {
+                        return timeToString((java.sql.Time) input);
+                    } else {
+                        return input.toString();
+                    }
+                }, String.class);
+            default:
+                return null;
+        }
+    }
 }
diff --git a/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcResource.java b/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcResource.java
index 0ff0e74a90..e8c4a5c24d 100644
--- a/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcResource.java
+++ b/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcResource.java
@@ -81,6 +81,7 @@ public class JdbcResource extends Resource {
     public static final String JDBC_OCEANBASE = "jdbc:oceanbase";
     public static final String JDBC_DB2 = "jdbc:db2";
     public static final String JDBC_GBASE = "jdbc:gbase";
+    public static final String JDBC_KINGBASE = "jdbc:kingbase8";
 
     public static final String MYSQL = "MYSQL";
     public static final String POSTGRESQL = "POSTGRESQL";
@@ -94,6 +95,7 @@ public class JdbcResource extends Resource {
     public static final String OCEANBASE_ORACLE = "OCEANBASE_ORACLE";
     public static final String DB2 = "DB2";
     public static final String GBASE = "GBASE";
+    public static final String KINGBASE = "KINGBASE";
 
     public static final String JDBC_PROPERTIES_PREFIX = "jdbc.";
     public static final String JDBC_URL = "jdbc_url";
@@ -365,6 +367,8 @@ public class JdbcResource extends Resource {
             return DB2;
         } else if (url.startsWith(JDBC_GBASE)) {
             return GBASE;
+        } else if (url.startsWith(JDBC_KINGBASE)) {
+            return KINGBASE;
         }
         throw new DdlException("Unsupported jdbc database type, please check jdbcUrl: " + url);
     }
diff --git a/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcTable.java b/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcTable.java
index 6dce40a268..98415e8ebb 100644
--- a/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcTable.java
+++ b/fe/fe-core/src/main/java/org/apache/doris/catalog/JdbcTable.java
@@ -117,6 +117,7 @@ public class JdbcTable extends Table {
         tempMap.put("oceanbase_oracle", TOdbcTableType.OCEANBASE_ORACLE);
         tempMap.put("db2", TOdbcTableType.DB2);
         tempMap.put("gbase", TOdbcTableType.GBASE);
+        tempMap.put("kingbase", TOdbcTableType.KINGBASE);
         TABLE_TYPE_MAP = Collections.unmodifiableMap(tempMap);
     }
 
@@ -475,6 +476,7 @@ public class JdbcTable extends Table {
             case PRESTO:
             case OCEANBASE_ORACLE:
             case SAP_HANA:
+            case KINGBASE:
                 return formatName(name, "\"", "\"", false, false);
             case ORACLE:
             case DB2:
@@ -500,6 +502,7 @@ public class JdbcTable extends Table {
             case ORACLE:
             case SAP_HANA:
             case DB2:
+            case KINGBASE:
                 return formatNameWithRemoteName(remoteName, "\"", "\"");
             default:
                 return remoteName;
diff --git a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcClient.java b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcClient.java
index 7d3ecdfe4d..a4aa3bdad0 100644
--- a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcClient.java
+++ b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcClient.java
@@ -93,6 +93,8 @@ public abstract class JdbcClient {
                 return new JdbcDB2Client(jdbcClientConfig);
             case JdbcResource.GBASE:
                 return new JdbcGbaseClient(jdbcClientConfig);
+            case JdbcResource.KINGBASE:
+                return new JdbcKingBaseClient(jdbcClientConfig);
             default:
                 throw new IllegalArgumentException("Unsupported DB type: " + dbType);
         }
diff --git a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcKingBaseClient.java b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcKingBaseClient.java
index 864f884fcd..eba67d4429 100644
--- a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcKingBaseClient.java
+++ b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcKingBaseClient.java
@@ -15,5 +15,97 @@
 // specific language governing permissions and limitations
 // under the License.
 
-package org.apache.doris.datasource.jdbc.client;public class JdbcKingBaseClient {
+package org.apache.doris.datasource.jdbc.client;
+
+import org.apache.doris.catalog.ScalarType;
+import org.apache.doris.catalog.Type;
+import org.apache.doris.datasource.jdbc.util.JdbcFieldSchema;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.sql.Types;
+
+public class JdbcKingBaseClient extends JdbcClient {
+
+    protected JdbcKingBaseClient(JdbcClientConfig jdbcClientConfig) {
+        super(jdbcClientConfig);
+        Connection conn = null;
+        Statement stmt = null;
+        ResultSet rs = null;
+        try {
+            conn = super.getConnection();
+            stmt = conn.createStatement();
+            rs = stmt.executeQuery("show database_mode");
+            if (rs.next()) {
+                String compatibilityMode = rs.getString(1);
+                if (!"ORACLE".equalsIgnoreCase(compatibilityMode)) {
+                    throw new JdbcClientException("Only KingBase Oracle compatibility mode is supported, but got: "
+                            + compatibilityMode);
+                }
+            } else {
+                throw new JdbcClientException("Failed to determine KingBase compatibility mode");
+            }
+        } catch (SQLException | JdbcClientException e) {
+            closeClient();
+            throw new JdbcClientException("Failed to initialize JdbcMySQLClient: %s", e.getMessage());
+        } finally {
+            close(rs, stmt, conn);
+        }
+    }
+
+    @Override
+    public String getTestQuery() {
+        return "SELECT 1 FROM dual";
+    }
+
+    @Override
+    protected Type jdbcTypeToDoris(JdbcFieldSchema fieldSchema) {
+        switch (fieldSchema.getDataType()) {
+            case Types.BIT:
+                return Type.BOOLEAN;
+            case Types.TINYINT:
+                return Type.TINYINT;
+            case Types.SMALLINT:
+                return Type.SMALLINT;
+            case Types.INTEGER:
+                return Type.INT;
+            case Types.BIGINT:
+                return Type.BIGINT;
+            case Types.FLOAT:
+            case Types.REAL:
+                return Type.FLOAT;
+            case Types.DOUBLE:
+                return Type.DOUBLE;
+            case Types.NUMERIC:
+            case Types.DECIMAL: {
+                int precision = fieldSchema.getColumnSize()
+                        .orElseThrow(() -> new IllegalArgumentException("Precision not present"));
+                int scale = fieldSchema.getDecimalDigits()
+                        .orElseThrow(() -> new JdbcClientException("Scale not present"));
+                return createDecimalOrStringType(precision, scale);
+            }
+            case Types.DATE:
+                return Type.DATEV2;
+            case Types.TIMESTAMP: {
+                int scale = fieldSchema.getDecimalDigits().orElse(0);
+                if (scale > 6) {
+                    scale = 6;
+                }
+                return ScalarType.createDatetimeV2Type(scale);
+            }
+            case Types.CHAR:
+                return ScalarType.createCharType(fieldSchema.requiredColumnSize());
+            case Types.TIME:
+            case Types.VARCHAR:
+            case Types.LONGVARCHAR:
+            case Types.CLOB:
+            case Types.NCLOB:
+            case Types.OTHER:
+                return ScalarType.createStringType();
+            default:
+                return Type.UNSUPPORTED;
+        }
+    }
 }
diff --git a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/source/JdbcScanNode.java b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/source/JdbcScanNode.java
index 31026e6b87..b54899b1ce 100644
--- a/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/source/JdbcScanNode.java
+++ b/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/source/JdbcScanNode.java
@@ -209,7 +209,8 @@ public class JdbcScanNode extends ExternalScanNode {
                 || jdbcType == TOdbcTableType.TRINO
                 || jdbcType == TOdbcTableType.PRESTO
                 || jdbcType == TOdbcTableType.OCEANBASE
-                || jdbcType == TOdbcTableType.GBASE)) {
+                || jdbcType == TOdbcTableType.GBASE
+                || jdbcType == TOdbcTableType.KINGBASE)) {
             sql.append(" LIMIT ").append(limit);
         }
 
diff --git a/gensrc/thrift/Types.thrift b/gensrc/thrift/Types.thrift
index e7752d4a0b..1cbcbe06c2 100644
--- a/gensrc/thrift/Types.thrift
+++ b/gensrc/thrift/Types.thrift
@@ -420,7 +420,8 @@ enum TOdbcTableType {
     OCEANBASE_ORACLE,
     NEBULA, // Deprecated
     DB2,
-    GBASE
+    GBASE,
+    KINGBASE
 }
 
 struct TJdbcExecutorCtorParams {
